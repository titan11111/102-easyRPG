<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ãƒªã‚¢ãƒ«æ£’äººé–“ã‚’åŠ©ã‘ã‚!ãƒ†ãƒˆãƒªã‚¹ãƒ–ãƒªãƒƒã‚¸</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* iOSã§ã®é•·æŠ¼ã—é¸æŠã‚’é˜²æ­¢ */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            /* iPhoneã®ã‚»ãƒ¼ãƒ•ã‚¨ãƒªã‚¢å¯¾å¿œ */
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            overflow: hidden;
            /* å…¨ä½“ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¨ã‚ºãƒ¼ãƒ ã‚’ç¦æ­¢ */
            touch-action: none;
        }
        
        #gameContainer {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            padding: 20px;
            max-width: 800px;
            width: 95%; /* ã‚¹ãƒãƒ›ã§æ¨ªå¹…ã„ã£ã±ã„ã« */
            position: relative;
            z-index: 10;
        }
        
        #gameTitle {
            text-align: center;
            color: #FF6B6B;
            font-size: clamp(18px, 5vw, 24px); /* ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ã« */
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #F0F8FF;
            border: 3px solid #4ECDC4;
            border-radius: 10px;
            max-width: 100%;
            /* ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã®ã‚¿ãƒƒãƒã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Œå…¨ã«åˆ¶å¾¡ */
            touch-action: none;
        }
        
        #controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
            justify-items: center;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }
        
        /* ãƒœã‚¿ãƒ³ã®é…ç½®èª¿æ•´ */
        .btn-spacer { grid-column: 1; }
        #rotateBtn { grid-column: 2; grid-row: 1; }
        #leftBtn { grid-column: 1; grid-row: 2; }
        #downBtn { grid-column: 2; grid-row: 2; }
        #rightBtn { grid-column: 3; grid-row: 2; }
        #startBtnContainer { 
            grid-column: 1 / -1; 
            width: 100%;
            margin-top: 10px;
            display: flex;
            justify-content: center;
        }

        button {
            padding: 0;
            width: 60px;
            height: 60px;
            font-size: 24px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            background: #4ECDC4;
            color: white;
            font-weight: bold;
            transition: transform 0.1s, background 0.1s;
            box-shadow: 0 4px 0 #3aa8a0; /* æŠ¼ã—ãŸæ„Ÿè§¦ã‚’å‡ºã™ãŸã‚ã®ç«‹ä½“æ„Ÿ */
            /* ã‚¿ãƒƒãƒ—æ™‚ã®é…å»¶ã‚’ãªãã™ */
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        button:active, button.active {
            transform: translateY(4px); /* æŠ¼ã—è¾¼ã¿ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
            box-shadow: 0 0 0 #3aa8a0;
            background: #3DA89E;
        }
        
        #startBtn {
            width: 100%;
            max-width: 200px;
            height: 50px;
            font-size: 18px;
            background: #FF6B6B;
            box-shadow: 0 4px 0 #d64545;
        }
        
        #startBtn:active {
            background: #E64545;
            box-shadow: 0 0 0 #d64545;
        }
        
        #info {
            text-align: center;
            margin-top: 10px;
            font-size: 12px;
            color: #888;
        }
        
        #score {
            text-align: center;
            font-size: 20px;
            color: #FF6B6B;
            margin-top: 5px;
            font-weight: bold;
            font-variant-numeric: tabular-nums; /* æ•°å­—ã®å¹…ã‚’æƒãˆã‚‹ */
        }

        /* ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼/ã‚¯ãƒªã‚¢æ™‚ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 15px;
            z-index: 20;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        #overlay h2 {
            font-size: 32px;
            margin-bottom: 20px;
        }
        
        #overlay p {
            font-size: 18px;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        #overlayBtn {
            background: #FF6B6B;
            width: auto;
            padding: 0 30px;
            box-shadow: 0 4px 0 #d64545;
        }

        @media (min-width: 600px) {
             /* PCã‚„ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆå‘ã‘ã®èª¿æ•´ */
            button {
                width: 70px;
                height: 70px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1 id="gameTitle">ğŸƒ ãƒªã‚¢ãƒ«æ£’äººé–“ã‚’åŠ©ã‘ã‚! ğŸ§±</h1>
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        <div id="score">ã‚¹ã‚³ã‚¢: 0</div>
        
        <div id="controls">
            <div class="btn-spacer"></div>
            <button id="rotateBtn" class="control-btn">ğŸ”„</button>
            <div class="btn-spacer"></div>
            
            <button id="leftBtn" class="control-btn">â¬…ï¸</button>
            <button id="downBtn" class="control-btn">â¬‡ï¸</button>
            <button id="rightBtn" class="control-btn">â¡ï¸</button>
            
            <div id="startBtnContainer">
                <button id="startBtn">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
            </div>
        </div>
        
        <div id="info">
            PC: çŸ¢å°ã‚­ãƒ¼ã§ç§»å‹•ã€ä¸Šã‚­ãƒ¼/ã‚¹ãƒšãƒ¼ã‚¹ã§å›è»¢<br>
            ã‚¹ãƒãƒ›: ãƒœã‚¿ãƒ³ã‚¿ãƒƒãƒ—
        </div>

        <div id="overlay">
            <h2 id="overlayTitle">TITLE</h2>
            <p id="overlayMessage">Message</p>
            <button id="overlayBtn">ã‚‚ã†ä¸€åº¦</button>
        </div>
    </div>

    <script>
        // ==========================================
        //  ãƒªã‚¢ãƒ«ãƒ»ãƒ©ãƒ³ãƒ‹ãƒ³ã‚°ãƒ»ã‚¹ãƒ†ã‚£ãƒƒã‚¯ãƒãƒ³ ã‚¯ãƒ©ã‚¹
        // ==========================================
        class RunningStickman {
            constructor(x, y, scale = 1.0, colorBody = '#34495e', colorLimbs = '#e74c3c') {
                this.x = x;
                this.y = y;
                this.scale = scale;
                this.colorBody = colorBody;
                this.colorLimbs = colorLimbs;
                this.colorLimbsBack = 'rgba(149, 165, 166, 0.7)';
                
                this.time = 0;
                this.speed = 0.16;
            }

            update() {
                this.time += this.speed;
            }

            draw(ctx) {
                const s = this.scale;
                
                // é‡å¿ƒã®è¨ˆç®—ï¼ˆè…°ã®ä½ç½®ï¼‰: åœ°é¢(this.y)ã‹ã‚‰è…°ã®é«˜ã•ã‚’è¨­å®š
                const centerY = this.y - 55 * s; 

                // ä¸Šä¸‹å‹•ï¼ˆãƒã‚¦ãƒ³ã‚¹ï¼‰
                const bouncePhase = Math.sin(this.time);
                const bounce = Math.abs(bouncePhase) * -6 * s;
                
                const hipX = this.x;
                const hipY = centerY + bounce;

                // å‰å‚¾è§’åº¦
                const leanAngle = 0.31;
                const torsoLength = 21 * s;
                const shoulderX = hipX + Math.sin(leanAngle) * torsoLength;
                const shoulderY = hipY - Math.cos(leanAngle) * torsoLength;

                // é ­éƒ¨ã®ä½ç½®
                const headDistance = 7.2 * s;
                const headX = shoulderX + Math.sin(leanAngle + 0.1) * headDistance;
                const headY = shoulderY - Math.cos(leanAngle + 0.1) * headDistance;

                // å¥¥å´ã®æ‰‹è¶³
                this.drawLeg(ctx, hipX, hipY, this.time + Math.PI, false);
                this.drawArm(ctx, shoulderX, shoulderY, hipY, this.time + Math.PI, false);
                
                // èƒ´ä½“ã¨é ­éƒ¨
                this.drawTorso(ctx, hipX, hipY, shoulderX, shoulderY, headX, headY);
                
                // æ‰‹å‰ã®æ‰‹è¶³
                this.drawLeg(ctx, hipX, hipY, this.time, true);
                this.drawArm(ctx, shoulderX, shoulderY, hipY, this.time, true);
            }

            drawTorso(ctx, hx, hy, sx, sy, headX, headY) {
                const s = this.scale;
                ctx.lineWidth = 3.6 * s;
                ctx.lineCap = 'round';
                ctx.strokeStyle = this.colorBody;

                ctx.beginPath();
                ctx.moveTo(hx, hy);
                ctx.lineTo(sx, sy);
                ctx.stroke();

                const headRadius = 5.1 * s;
                ctx.beginPath();
                ctx.arc(headX, headY, headRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.colorBody;
                ctx.fill();

                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(headX + 1.5 * s, headY - 0.6 * s, 0.9 * s, 0, Math.PI * 2);
                ctx.fill();
            }

            drawArm(ctx, sx, sy, hipY, t, isFront) {
                const s = this.scale;
                const color = isFront ? this.colorLimbs : this.colorLimbsBack;
                ctx.strokeStyle = color;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                const armSwing = Math.sin(t + Math.PI);
                const armForwardBack = armSwing * 13.5 * s;
                const armCenterY = (sy + hipY) / 2;
                
                const elbowX = sx + armForwardBack;
                const elbowY = armCenterY + (armSwing * 4.5 * s);
                
                const elbowAngle = armSwing > 0 ? 2.2 : 1.5;
                const upperArmLen = 12 * s;
                const lowerArmLen = 10.5 * s;
                
                const shoulderToElbowDx = elbowX - sx;
                const shoulderToElbowDy = elbowY - sy;
                const shoulderAngle = Math.atan2(shoulderToElbowDx, shoulderToElbowDy);
                
                const handX = elbowX + Math.sin(shoulderAngle + elbowAngle) * lowerArmLen;
                const handY = elbowY + Math.cos(shoulderAngle + elbowAngle) * lowerArmLen;

                ctx.lineWidth = 2.1 * s;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(elbowX, elbowY);
                ctx.lineTo(handX, handY);
                ctx.stroke();

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(handX, handY, 1.5 * s, 0, Math.PI * 2);
                ctx.fill();
            }

            drawLeg(ctx, hx, hy, t, isFront) {
                const s = this.scale;
                const color = isFront ? this.colorLimbs : this.colorLimbsBack;
                ctx.strokeStyle = color;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                const legSwing = Math.sin(t);
                const hipAngle = legSwing * 0.75 + 0.45;
                
                let kneeAngle;
                if (legSwing > 0) {
                    kneeAngle = (Math.cos(t) + 1) * 1.1;
                } else {
                    kneeAngle = (Math.cos(t) + 1) * 0.25;
                }

                const thighLen = 16.5 * s;
                const shinLen = 15 * s;

                const kneeX = hx + Math.sin(hipAngle) * thighLen;
                const kneeY = hy + Math.cos(hipAngle) * thighLen;
                const ankleX = kneeX + Math.sin(hipAngle - kneeAngle) * shinLen;
                const ankleY = kneeY + Math.cos(hipAngle - kneeAngle) * shinLen;

                ctx.lineWidth = 2.7 * s;
                ctx.beginPath();
                ctx.moveTo(hx, hy);
                ctx.lineTo(kneeX, kneeY);
                ctx.lineTo(ankleX, ankleY);
                ctx.stroke();

                const footAngle = legSwing > 0 ? -0.2 : 0.1;
                const footX = ankleX + Math.cos(footAngle) * 5.4 * s;
                const footY = ankleY + Math.sin(footAngle) * 5.4 * s;
                
                ctx.lineWidth = 3.3 * s;
                ctx.beginPath();
                ctx.moveTo(ankleX, ankleY);
                ctx.lineTo(footX, footY);
                ctx.stroke();

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(footX, footY, 1.8 * s, 0, Math.PI * 2);
                ctx.fill();
            }
        }


        // ==========================================
        //  ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯
        // ==========================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const downBtn = document.getElementById('downBtn');
        const rotateBtn = document.getElementById('rotateBtn');
        const scoreDisplay = document.getElementById('score');
        
        // UXç”¨ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è¦ç´ 
        const overlay = document.getElementById('overlay');
        const overlayTitle = document.getElementById('overlayTitle');
        const overlayMessage = document.getElementById('overlayMessage');
        const overlayBtn = document.getElementById('overlayBtn');

        function resizeCanvas() {
            const container = canvas.parentElement;
            // paddingåˆ†ã‚’å¼•ã„ã¦è¨ˆç®—
            const maxWidth = Math.min(600, container.clientWidth - 40);
            canvas.style.width = maxWidth + 'px';
            canvas.style.height = (maxWidth * 400 / 600) + 'px';
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const GRID_SIZE = 20;
        const COLS = 30;
        const ROWS = 20;
        const HOLE_START = 10;
        const HOLE_END = 20;
        const HOLE_DEPTH = 12;

        let gameRunning = false;
        let score = 0;
        
        let stickman = { 
            x: 1, 
            y: 12.7, 
            speed: 0.002, 
            falling: false, 
            fallY: 0,
            renderer: null
        };
        
        let grid = [];
        let currentPiece = null;
        let nextPieceTimer = 0;
        let gameOver = false;

        const PIECES = [
            [[1,1,1,1]], 
            [[1,1],[1,1]], 
            [[1,1,1],[0,1,0]], 
            [[1,1,1],[1,0,0]], 
            [[1,1,1],[0,0,1]], 
            [[1,1,0],[0,1,1]], 
            [[0,1,1],[1,1,0]] 
        ];

        const COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE'];

        function initGrid() {
            grid = [];
            for (let r = 0; r < ROWS; r++) {
                grid[r] = [];
                for (let c = 0; c < COLS; c++) {
                    if (r >= HOLE_DEPTH && c >= HOLE_START && c < HOLE_END) {
                        grid[r][c] = 0;
                    } else if (r >= HOLE_DEPTH) {
                        grid[r][c] = 1;
                    } else {
                        grid[r][c] = 0;
                    }
                }
            }
        }

        function createPiece() {
            const shapeIndex = Math.floor(Math.random() * PIECES.length);
            const shape = PIECES[shapeIndex];
            return {
                shape: shape,
                color: COLORS[shapeIndex],
                x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
                y: 0
            };
        }

        function canPlace(piece, x, y) {
            for (let r = 0; r < piece.shape.length; r++) {
                for (let c = 0; c < piece.shape[r].length; c++) {
                    if (piece.shape[r][c]) {
                        const newY = y + r;
                        const newX = x + c;
                        if (newX < 0 || newX >= COLS || newY >= ROWS) return false;
                        if (newY >= 0 && grid[newY][newX] !== 0) return false;
                    }
                }
            }
            return true;
        }

        function placePiece(piece) {
            for (let r = 0; r < piece.shape.length; r++) {
                for (let c = 0; c < piece.shape[r].length; c++) {
                    if (piece.shape[r][c]) {
                        const y = piece.y + r;
                        const x = piece.x + c;
                        if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                            grid[y][x] = 2;
                        }
                    }
                }
            }
        }

        function rotatePiece(piece) {
            const newShape = piece.shape[0].map((_, i) =>
                piece.shape.map(row => row[i]).reverse()
            );
            const newPiece = { ...piece, shape: newShape };
            if (canPlace(newPiece, newPiece.x, newPiece.y)) {
                piece.shape = newShape;
            }
        }

        function movePiece(dx, dy) {
            if (!currentPiece || !gameRunning) return;
            const newX = currentPiece.x + dx;
            const newY = currentPiece.y + dy;
            
            if (canPlace(currentPiece, newX, newY)) {
                currentPiece.x = newX;
                currentPiece.y = newY;
                draw();
                return true;
            }
            return false;
        }

        function canWalk(x) {
            const col = Math.floor(x);
            if (col < 0 || col >= COLS) return true;
            const footY = Math.floor(stickman.y) + 1;
            
            if (col >= HOLE_START && col < HOLE_END) {
                if (footY < ROWS && grid[footY][col] !== 0) {
                    return true;
                }
                return false;
            }
            return true;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cellWidth = canvas.width / COLS;
            const cellHeight = canvas.height / ROWS;
            
            // èƒŒæ™¯ï¼ˆåœ°é¢ãƒ»ãƒ–ãƒ­ãƒƒã‚¯ï¼‰
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (grid[r][c] === 1) {
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(c * cellWidth, r * cellHeight, cellWidth, cellHeight);
                        ctx.strokeStyle = '#654321';
                        ctx.strokeRect(c * cellWidth, r * cellHeight, cellWidth, cellHeight);
                    } else if (grid[r][c] === 2) {
                        ctx.fillStyle = '#FFA500';
                        ctx.fillRect(c * cellWidth, r * cellHeight, cellWidth, cellHeight);
                        ctx.strokeStyle = '#FF8C00';
                        ctx.strokeRect(c * cellWidth, r * cellHeight, cellWidth, cellHeight);
                    }
                }
            }
            
            // ç©´ã®èƒŒæ™¯
            ctx.fillStyle = '#333';
            for (let r = HOLE_DEPTH; r < ROWS; r++) {
                for (let c = HOLE_START; c < HOLE_END; c++) {
                    if (grid[r][c] === 0) {
                        ctx.fillRect(c * cellWidth, r * cellHeight, cellWidth, cellHeight);
                    }
                }
            }
            
            // æ“ä½œä¸­ã®ãƒ–ãƒ­ãƒƒã‚¯
            if (currentPiece) {
                ctx.fillStyle = currentPiece.color;
                for (let r = 0; r < currentPiece.shape.length; r++) {
                    for (let c = 0; c < currentPiece.shape[r].length; c++) {
                        if (currentPiece.shape[r][c]) {
                            ctx.fillRect(
                                (currentPiece.x + c) * cellWidth,
                                (currentPiece.y + r) * cellHeight,
                                cellWidth,
                                cellHeight
                            );
                            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                            ctx.strokeRect(
                                (currentPiece.x + c) * cellWidth,
                                (currentPiece.y + r) * cellHeight,
                                cellWidth,
                                cellHeight
                            );
                        }
                    }
                }
            }
            
            // ------------------------------------------
            // ãƒªã‚¢ãƒ«æ£’äººé–“ã®æç”»
            // ------------------------------------------
            if (stickman.renderer) {
                const runnerScale = (cellHeight / 40) * 3.0;
                const pixelX = stickman.x * cellWidth + (cellWidth / 2);
                const pixelY = (stickman.y + 0.8) * cellHeight; 

                stickman.renderer.x = pixelX;
                stickman.renderer.y = pixelY;
                stickman.renderer.scale = runnerScale;

                if (stickman.falling) {
                    stickman.renderer.y += stickman.fallY;
                    stickman.fallY += 2;
                    stickman.renderer.draw(ctx);
                } else {
                    stickman.renderer.draw(ctx);
                }
            }
        }
        
        // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è¡¨ç¤ºé–¢æ•°ï¼ˆUXå‘ä¸Šï¼‰
        function showOverlay(title, msg, success) {
            overlayTitle.textContent = title;
            overlayTitle.style.color = success ? '#FFD700' : '#FF6B6B';
            overlayMessage.innerHTML = msg;
            overlay.style.display = 'flex';
        }

        function gameLoop() {
            if (!gameRunning) return;
            
            // ãƒ–ãƒ­ãƒƒã‚¯è½ä¸‹
            if (currentPiece) {
                nextPieceTimer++;
                if (nextPieceTimer > 60) {
                    if (!movePiece(0, 1)) {
                        placePiece(currentPiece);
                        currentPiece = null;
                        nextPieceTimer = 0;
                    } else {
                        nextPieceTimer = 0;
                    }
                }
            } else {
                nextPieceTimer++;
                if (nextPieceTimer > 30) {
                    currentPiece = createPiece();
                    nextPieceTimer = 0;
                }
            }
            
            // æ£’äººé–“ã®ç§»å‹•åˆ¤å®š
            if (canWalk(stickman.x + stickman.speed)) {
                stickman.x += stickman.speed;
                if (stickman.renderer) {
                    stickman.renderer.update();
                }
                
                // ã‚´ãƒ¼ãƒ«åˆ¤å®š
                if (stickman.x > HOLE_END && !gameOver) {
                    score += 100;
                    scoreDisplay.textContent = 'ã‚¹ã‚³ã‚¢: ' + score;
                    gameOver = true;
                    gameRunning = false;
                    
                    // ã‚¢ãƒ©ãƒ¼ãƒˆã®ä»£ã‚ã‚Šã«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è¡¨ç¤º
                    setTimeout(() => {
                        showOverlay(
                            'ğŸ‰ æˆåŠŸ! ğŸ‰', 
                            'ãŠã‚ã§ã¨ã†!<br>ãƒªã‚¢ãƒ«ãªå½¼ã‚’åŠ©ã‘ã¾ã—ãŸ!<br><br>ã‚¹ã‚³ã‚¢: ' + score, 
                            true
                        );
                    }, 500);
                }
            } else {
                // è½ä¸‹
                if (!stickman.falling) {
                    stickman.falling = true;
                    stickman.fallY = 0;
                    
                    setTimeout(() => {
                        gameRunning = false;
                        gameOver = true;
                        
                        // ã‚¢ãƒ©ãƒ¼ãƒˆã®ä»£ã‚ã‚Šã«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è¡¨ç¤º
                        showOverlay(
                            'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼', 
                            'å½¼ãŒç©´ã«è½ã¡ã¦ã—ã¾ã„ã¾ã—ãŸ...<br><br>ã‚¹ã‚³ã‚¢: ' + score, 
                            false
                        );
                    }, 1500);
                }
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            gameRunning = false;
            score = 0;
            stickman = { 
                x: 1, 
                y: 13.2, 
                speed: 0.002, 
                falling: false, 
                fallY: 0,
                renderer: new RunningStickman(0, 0, 1.0)
            };
            
            currentPiece = null;
            nextPieceTimer = 0;
            gameOver = false;
            initGrid();
            scoreDisplay.textContent = 'ã‚¹ã‚³ã‚¢: 0';
            startBtn.textContent = 'ã‚¹ã‚¿ãƒ¼ãƒˆ';
            
            // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’éš ã™
            overlay.style.display = 'none';
            
            draw();
        }

        function startGame() {
            if (!gameRunning) {
                if (gameOver) {
                    resetGame();
                    setTimeout(() => {
                        gameRunning = true;
                        gameOver = false;
                        startBtn.textContent = 'ãƒªã‚»ãƒƒãƒˆ';
                        gameLoop();
                    }, 100);
                } else {
                    gameRunning = true;
                    gameOver = false;
                    startBtn.textContent = 'ãƒªã‚»ãƒƒãƒˆ';
                    gameLoop();
                }
            } else {
                resetGame();
            }
        }
        
        // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®ãƒœã‚¿ãƒ³ã«ã‚‚ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½ã‚’å‰²ã‚Šå½“ã¦
        overlayBtn.addEventListener('click', () => {
            resetGame();
            startGame();
        });

        // ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
        startBtn.addEventListener('click', startGame);
        
        let buttonInterval = null;
        function startButtonPress(action) {
            if (!gameRunning) return;
            action();
            buttonInterval = setInterval(action, 100);
        }
        function stopButtonPress() {
            if (buttonInterval) {
                clearInterval(buttonInterval);
                buttonInterval = null;
            }
        }
        
        // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã®UXæœ€é©åŒ–ãƒ˜ãƒ«ãƒ‘ãƒ¼
        function addTouchControls(btn, action) {
            // ãƒã‚¦ã‚¹
            btn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                btn.classList.add('active'); // è¦–è¦šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ç”¨
                startButtonPress(action);
            });
            window.addEventListener('mouseup', () => {
                btn.classList.remove('active');
                stopButtonPress();
            });

            // ã‚¿ãƒƒãƒ (passive: false ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢)
            btn.addEventListener('touchstart', (e) => {
                if (e.cancelable) e.preventDefault(); // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã‚ºãƒ¼ãƒ é˜²æ­¢ã®è¦
                btn.classList.add('active');
                startButtonPress(action);
            }, { passive: false });
            
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                btn.classList.remove('active');
                stopButtonPress();
            });
            
            // ã‚¿ãƒƒãƒãŒãƒœã‚¿ãƒ³å¤–ã«å‡ºãŸå ´åˆãªã©ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            btn.addEventListener('touchcancel', () => {
                btn.classList.remove('active');
                stopButtonPress();
            });
        }
        
        addTouchControls(leftBtn, () => movePiece(-1, 0));
        addTouchControls(rightBtn, () => movePiece(1, 0));
        addTouchControls(downBtn, () => movePiece(0, 1));
        
        // å›è»¢ãƒœã‚¿ãƒ³ï¼ˆé•·æŠ¼ã—ä¸è¦ã€å˜ç™ºã‚¯ãƒªãƒƒã‚¯ï¼‰
        const handleRotate = (e) => {
            if(e.cancelable) e.preventDefault();
            rotateBtn.classList.add('active');
            if (currentPiece && gameRunning) {
                rotatePiece(currentPiece);
                draw();
            }
            setTimeout(() => rotateBtn.classList.remove('active'), 100);
        };
        
        rotateBtn.addEventListener('mousedown', handleRotate);
        rotateBtn.addEventListener('touchstart', handleRotate, { passive: false });

        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;
            if (e.key === 'ArrowLeft') movePiece(-1, 0);
            if (e.key === 'ArrowRight') movePiece(1, 0);
            if (e.key === 'ArrowDown') movePiece(0, 1);
            if (e.key === 'ArrowUp' || e.key === ' ') currentPiece && rotatePiece(currentPiece);
        });

        let touchStartX = 0;
        let touchStartY = 0;
        
        // ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã®ã‚¹ãƒ¯ã‚¤ãƒ—æ“ä½œï¼ˆUXå‘ä¸Š: æ„Ÿåº¦èª¿æ•´ï¼‰
        canvas.addEventListener('touchstart', (e) => {
            // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢
            if(e.cancelable) e.preventDefault(); 
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if(e.cancelable) e.preventDefault();
            if (!gameRunning) return;
            
            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            
            const diffX = touchX - touchStartX;
            const diffY = touchY - touchStartY;
            
            // Xæ–¹å‘ã®ç§»å‹•ï¼ˆæ„Ÿåº¦é–¾å€¤ 20pxï¼‰
            if (Math.abs(diffX) > 20) {
                if (diffX > 0) movePiece(1, 0);
                else movePiece(-1, 0);
                touchStartX = touchX; // é€£ç¶šç§»å‹•ã®ãŸã‚ã«åŸºæº–ç‚¹ã‚’æ›´æ–°
            }
            
            // ä¸‹æ–¹å‘ã¸ã®ãƒ•ãƒªãƒƒã‚¯ï¼ˆé«˜é€Ÿè½ä¸‹ï¼‰
            if (diffY > 40) {
                movePiece(0, 1);
                touchStartY = touchY;
            }
            
        }, { passive: false });
        
        // ã‚¿ãƒƒãƒ—ã§å›è»¢
        canvas.addEventListener('touchend', (e) => {
           // ç§»å‹•é‡ãŒå°‘ãªã‘ã‚Œã°å›è»¢ã¨ã¿ãªã™ï¼ˆã‚¿ãƒƒãƒ—åˆ¤å®šï¼‰
           // startã¨endã®åº§æ¨™ä¿æŒãŒå¿…è¦ã ãŒã€ç°¡æ˜“çš„ã«touchmoveãŒç™ºç«ã—ã¦ã„ãªã‘ã‚Œã°å›è»¢ã¨ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚‚å¯
           // ä»Šå›ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯å„ªå…ˆã§ã€ã‚¹ãƒ¯ã‚¤ãƒ—ã®ã¿å®Ÿè£…
        });
        
        // ç”»é¢å…¨ä½“ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢ï¼ˆã‚²ãƒ¼ãƒ é ˜åŸŸå†…ï¼‰
        document.body.addEventListener('touchmove', function(e) {
            // ã‚²ãƒ¼ãƒ ã‚³ãƒ³ãƒ†ãƒŠå†…ã§ã®ã‚¿ãƒƒãƒã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã•ã›ãªã„
            if (e.target.closest('#gameContainer')) {
                e.preventDefault();
            }
        }, { passive: false });

        // åˆå›åˆæœŸåŒ–
        initGrid();
        stickman.renderer = new RunningStickman(0, 0, 1.0);
        draw();
    </script>
</body>
</html>
